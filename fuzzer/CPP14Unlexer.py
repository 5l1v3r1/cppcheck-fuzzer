# Generated by Grammarinator 19.3

from itertools import chain
from grammarinator.runtime import *

charset_0 = list(chain(*multirange_diff(printable_unicode_ranges, [(10, 11)])))
charset_1 = list(chain(*multirange_diff(printable_unicode_ranges, [(10, 11)])))
charset_2 = list(chain(*multirange_diff(printable_unicode_ranges, [(10, 11)])))
charset_3 = list(chain(range(97, 123), range(65, 91), range(95, 96)))
charset_4 = list(chain(range(48, 58)))
charset_5 = list(chain(range(49, 58)))
charset_6 = list(chain(range(48, 56)))
charset_7 = list(chain(range(48, 58), range(97, 103), range(65, 71)))
charset_8 = list(chain(range(48, 49), range(49, 50)))
charset_9 = list(chain(range(117, 118), range(85, 86)))
charset_10 = list(chain(range(108, 109), range(76, 77)))
charset_11 = list(chain(*multirange_diff(printable_unicode_ranges, [(10, 11),(13, 14),(39, 40),(92, 93)])))
charset_12 = list(chain(range(43, 44), range(45, 46)))
charset_13 = list(chain(range(102, 103), range(108, 109), range(70, 71), range(76, 77)))
charset_14 = list(chain(*multirange_diff(printable_unicode_ranges, [(10, 11),(13, 14),(34, 35),(92, 93)])))
charset_15 = list(chain(range(32, 33), range(9, 10)))
charset_16 = list(chain(*multirange_diff(printable_unicode_ranges, [(10, 11),(13, 14)])))
charset_17 = list(chain(*multirange_diff(printable_unicode_ranges, [(40, 41),(41, 42),(91, 92),(93, 94),(123, 124),(125, 126)])))


class CPP14Unlexer(Grammarinator):

    def __init__(self, *, max_depth=float('inf'), weights=None, cooldown=1.0):
        super(CPP14Unlexer, self).__init__()
        self.unlexer = self
        self.max_depth = max_depth
        self.weights = weights or dict()
        self.cooldown = cooldown

    def EOF(self, *args, **kwargs):
        pass

    @depthcontrol
    def MultiLineMacro(self):
        current = self.create_node(UnlexerRule(name='MultiLineMacro'))
        current += self.create_node(UnlexerRule(src='#'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                if self.unlexer.max_depth >= 0:
                    for _ in self.zero_or_more():
                        current += UnlexerRule(src=self.char_from_list(charset_0))

                current += self.create_node(UnlexerRule(src='\\'))
                if self.unlexer.max_depth >= 0:
                    for _ in self.zero_or_one():
                        current += self.create_node(UnlexerRule(src='\r'))

                current += self.create_node(UnlexerRule(src='\n'))

        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += UnlexerRule(src=self.char_from_list(charset_1))

        return current
    MultiLineMacro.min_depth = 0

    @depthcontrol
    def Directive(self):
        current = self.create_node(UnlexerRule(name='Directive'))
        current += self.create_node(UnlexerRule(src='#'))
        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_more():
                current += UnlexerRule(src=self.char_from_list(charset_2))

        return current
    Directive.min_depth = 0

    @depthcontrol
    def Alignas(self):
        current = self.create_node(UnlexerRule(name='Alignas'))
        current += self.create_node(UnlexerRule(src='alignas'))
        return current
    Alignas.min_depth = 0

    @depthcontrol
    def Alignof(self):
        current = self.create_node(UnlexerRule(name='Alignof'))
        current += self.create_node(UnlexerRule(src='alignof'))
        return current
    Alignof.min_depth = 0

    @depthcontrol
    def Asm(self):
        current = self.create_node(UnlexerRule(name='Asm'))
        current += self.create_node(UnlexerRule(src='asm'))
        return current
    Asm.min_depth = 0

    @depthcontrol
    def Auto(self):
        current = self.create_node(UnlexerRule(name='Auto'))
        current += self.create_node(UnlexerRule(src='auto'))
        return current
    Auto.min_depth = 0

    @depthcontrol
    def Bool(self):
        current = self.create_node(UnlexerRule(name='Bool'))
        current += self.create_node(UnlexerRule(src='bool'))
        return current
    Bool.min_depth = 0

    @depthcontrol
    def Break(self):
        current = self.create_node(UnlexerRule(name='Break'))
        current += self.create_node(UnlexerRule(src='break'))
        return current
    Break.min_depth = 0

    @depthcontrol
    def Case(self):
        current = self.create_node(UnlexerRule(name='Case'))
        current += self.create_node(UnlexerRule(src='case'))
        return current
    Case.min_depth = 0

    @depthcontrol
    def Catch(self):
        current = self.create_node(UnlexerRule(name='Catch'))
        current += self.create_node(UnlexerRule(src='catch'))
        return current
    Catch.min_depth = 0

    @depthcontrol
    def Char(self):
        current = self.create_node(UnlexerRule(name='Char'))
        current += self.create_node(UnlexerRule(src='char'))
        return current
    Char.min_depth = 0

    @depthcontrol
    def Char16(self):
        current = self.create_node(UnlexerRule(name='Char16'))
        current += self.create_node(UnlexerRule(src='char16_t'))
        return current
    Char16.min_depth = 0

    @depthcontrol
    def Char32(self):
        current = self.create_node(UnlexerRule(name='Char32'))
        current += self.create_node(UnlexerRule(src='char32_t'))
        return current
    Char32.min_depth = 0

    @depthcontrol
    def Class(self):
        current = self.create_node(UnlexerRule(name='Class'))
        current += self.create_node(UnlexerRule(src='class'))
        return current
    Class.min_depth = 0

    @depthcontrol
    def Const(self):
        current = self.create_node(UnlexerRule(name='Const'))
        current += self.create_node(UnlexerRule(src='const'))
        return current
    Const.min_depth = 0

    @depthcontrol
    def Constexpr(self):
        current = self.create_node(UnlexerRule(name='Constexpr'))
        current += self.create_node(UnlexerRule(src='constexpr'))
        return current
    Constexpr.min_depth = 0

    @depthcontrol
    def Const_cast(self):
        current = self.create_node(UnlexerRule(name='Const_cast'))
        current += self.create_node(UnlexerRule(src='const_cast'))
        return current
    Const_cast.min_depth = 0

    @depthcontrol
    def Continue(self):
        current = self.create_node(UnlexerRule(name='Continue'))
        current += self.create_node(UnlexerRule(src='continue'))
        return current
    Continue.min_depth = 0

    @depthcontrol
    def Decltype(self):
        current = self.create_node(UnlexerRule(name='Decltype'))
        current += self.create_node(UnlexerRule(src='decltype'))
        return current
    Decltype.min_depth = 0

    @depthcontrol
    def Default(self):
        current = self.create_node(UnlexerRule(name='Default'))
        current += self.create_node(UnlexerRule(src='default'))
        return current
    Default.min_depth = 0

    @depthcontrol
    def Delete(self):
        current = self.create_node(UnlexerRule(name='Delete'))
        current += self.create_node(UnlexerRule(src='delete'))
        return current
    Delete.min_depth = 0

    @depthcontrol
    def Do(self):
        current = self.create_node(UnlexerRule(name='Do'))
        current += self.create_node(UnlexerRule(src='do'))
        return current
    Do.min_depth = 0

    @depthcontrol
    def Double(self):
        current = self.create_node(UnlexerRule(name='Double'))
        current += self.create_node(UnlexerRule(src='double'))
        return current
    Double.min_depth = 0

    @depthcontrol
    def Dynamic_cast(self):
        current = self.create_node(UnlexerRule(name='Dynamic_cast'))
        current += self.create_node(UnlexerRule(src='dynamic_cast'))
        return current
    Dynamic_cast.min_depth = 0

    @depthcontrol
    def Else(self):
        current = self.create_node(UnlexerRule(name='Else'))
        current += self.create_node(UnlexerRule(src='else'))
        return current
    Else.min_depth = 0

    @depthcontrol
    def Enum(self):
        current = self.create_node(UnlexerRule(name='Enum'))
        current += self.create_node(UnlexerRule(src='enum'))
        return current
    Enum.min_depth = 0

    @depthcontrol
    def Explicit(self):
        current = self.create_node(UnlexerRule(name='Explicit'))
        current += self.create_node(UnlexerRule(src='explicit'))
        return current
    Explicit.min_depth = 0

    @depthcontrol
    def Export(self):
        current = self.create_node(UnlexerRule(name='Export'))
        current += self.create_node(UnlexerRule(src='export'))
        return current
    Export.min_depth = 0

    @depthcontrol
    def Extern(self):
        current = self.create_node(UnlexerRule(name='Extern'))
        current += self.create_node(UnlexerRule(src='extern'))
        return current
    Extern.min_depth = 0

    @depthcontrol
    def False_(self):
        current = self.create_node(UnlexerRule(name='False_'))
        current += self.create_node(UnlexerRule(src='false'))
        return current
    False_.min_depth = 0

    @depthcontrol
    def Final(self):
        current = self.create_node(UnlexerRule(name='Final'))
        current += self.create_node(UnlexerRule(src='final'))
        return current
    Final.min_depth = 0

    @depthcontrol
    def Float(self):
        current = self.create_node(UnlexerRule(name='Float'))
        current += self.create_node(UnlexerRule(src='float'))
        return current
    Float.min_depth = 0

    @depthcontrol
    def For(self):
        current = self.create_node(UnlexerRule(name='For'))
        current += self.create_node(UnlexerRule(src='for'))
        return current
    For.min_depth = 0

    @depthcontrol
    def Friend(self):
        current = self.create_node(UnlexerRule(name='Friend'))
        current += self.create_node(UnlexerRule(src='friend'))
        return current
    Friend.min_depth = 0

    @depthcontrol
    def Goto(self):
        current = self.create_node(UnlexerRule(name='Goto'))
        current += self.create_node(UnlexerRule(src='goto'))
        return current
    Goto.min_depth = 0

    @depthcontrol
    def If(self):
        current = self.create_node(UnlexerRule(name='If'))
        current += self.create_node(UnlexerRule(src='if'))
        return current
    If.min_depth = 0

    @depthcontrol
    def Inline(self):
        current = self.create_node(UnlexerRule(name='Inline'))
        current += self.create_node(UnlexerRule(src='inline'))
        return current
    Inline.min_depth = 0

    @depthcontrol
    def Int(self):
        current = self.create_node(UnlexerRule(name='Int'))
        current += self.create_node(UnlexerRule(src='int'))
        return current
    Int.min_depth = 0

    @depthcontrol
    def Long(self):
        current = self.create_node(UnlexerRule(name='Long'))
        current += self.create_node(UnlexerRule(src='long'))
        return current
    Long.min_depth = 0

    @depthcontrol
    def Mutable(self):
        current = self.create_node(UnlexerRule(name='Mutable'))
        current += self.create_node(UnlexerRule(src='mutable'))
        return current
    Mutable.min_depth = 0

    @depthcontrol
    def Namespace(self):
        current = self.create_node(UnlexerRule(name='Namespace'))
        current += self.create_node(UnlexerRule(src='namespace'))
        return current
    Namespace.min_depth = 0

    @depthcontrol
    def New(self):
        current = self.create_node(UnlexerRule(name='New'))
        current += self.create_node(UnlexerRule(src='new'))
        return current
    New.min_depth = 0

    @depthcontrol
    def Noexcept(self):
        current = self.create_node(UnlexerRule(name='Noexcept'))
        current += self.create_node(UnlexerRule(src='noexcept'))
        return current
    Noexcept.min_depth = 0

    @depthcontrol
    def Nullptr(self):
        current = self.create_node(UnlexerRule(name='Nullptr'))
        current += self.create_node(UnlexerRule(src='nullptr'))
        return current
    Nullptr.min_depth = 0

    @depthcontrol
    def Operator(self):
        current = self.create_node(UnlexerRule(name='Operator'))
        current += self.create_node(UnlexerRule(src='operator'))
        return current
    Operator.min_depth = 0

    @depthcontrol
    def Override(self):
        current = self.create_node(UnlexerRule(name='Override'))
        current += self.create_node(UnlexerRule(src='override'))
        return current
    Override.min_depth = 0

    @depthcontrol
    def Private(self):
        current = self.create_node(UnlexerRule(name='Private'))
        current += self.create_node(UnlexerRule(src='private'))
        return current
    Private.min_depth = 0

    @depthcontrol
    def Protected(self):
        current = self.create_node(UnlexerRule(name='Protected'))
        current += self.create_node(UnlexerRule(src='protected'))
        return current
    Protected.min_depth = 0

    @depthcontrol
    def Public(self):
        current = self.create_node(UnlexerRule(name='Public'))
        current += self.create_node(UnlexerRule(src='public'))
        return current
    Public.min_depth = 0

    @depthcontrol
    def Register(self):
        current = self.create_node(UnlexerRule(name='Register'))
        current += self.create_node(UnlexerRule(src='register'))
        return current
    Register.min_depth = 0

    @depthcontrol
    def Reinterpret_cast(self):
        current = self.create_node(UnlexerRule(name='Reinterpret_cast'))
        current += self.create_node(UnlexerRule(src='reinterpret_cast'))
        return current
    Reinterpret_cast.min_depth = 0

    @depthcontrol
    def Return(self):
        current = self.create_node(UnlexerRule(name='Return'))
        current += self.create_node(UnlexerRule(src='return'))
        return current
    Return.min_depth = 0

    @depthcontrol
    def Short(self):
        current = self.create_node(UnlexerRule(name='Short'))
        current += self.create_node(UnlexerRule(src='short'))
        return current
    Short.min_depth = 0

    @depthcontrol
    def Signed(self):
        current = self.create_node(UnlexerRule(name='Signed'))
        current += self.create_node(UnlexerRule(src='signed'))
        return current
    Signed.min_depth = 0

    @depthcontrol
    def Sizeof(self):
        current = self.create_node(UnlexerRule(name='Sizeof'))
        current += self.create_node(UnlexerRule(src='sizeof'))
        return current
    Sizeof.min_depth = 0

    @depthcontrol
    def Static(self):
        current = self.create_node(UnlexerRule(name='Static'))
        current += self.create_node(UnlexerRule(src='static'))
        return current
    Static.min_depth = 0

    @depthcontrol
    def Static_assert(self):
        current = self.create_node(UnlexerRule(name='Static_assert'))
        current += self.create_node(UnlexerRule(src='static_assert'))
        return current
    Static_assert.min_depth = 0

    @depthcontrol
    def Static_cast(self):
        current = self.create_node(UnlexerRule(name='Static_cast'))
        current += self.create_node(UnlexerRule(src='static_cast'))
        return current
    Static_cast.min_depth = 0

    @depthcontrol
    def Struct(self):
        current = self.create_node(UnlexerRule(name='Struct'))
        current += self.create_node(UnlexerRule(src='struct'))
        return current
    Struct.min_depth = 0

    @depthcontrol
    def Switch(self):
        current = self.create_node(UnlexerRule(name='Switch'))
        current += self.create_node(UnlexerRule(src='switch'))
        return current
    Switch.min_depth = 0

    @depthcontrol
    def Template(self):
        current = self.create_node(UnlexerRule(name='Template'))
        current += self.create_node(UnlexerRule(src='template'))
        return current
    Template.min_depth = 0

    @depthcontrol
    def This(self):
        current = self.create_node(UnlexerRule(name='This'))
        current += self.create_node(UnlexerRule(src='this'))
        return current
    This.min_depth = 0

    @depthcontrol
    def Thread_local(self):
        current = self.create_node(UnlexerRule(name='Thread_local'))
        current += self.create_node(UnlexerRule(src='thread_local'))
        return current
    Thread_local.min_depth = 0

    @depthcontrol
    def Throw(self):
        current = self.create_node(UnlexerRule(name='Throw'))
        current += self.create_node(UnlexerRule(src='throw'))
        return current
    Throw.min_depth = 0

    @depthcontrol
    def True_(self):
        current = self.create_node(UnlexerRule(name='True_'))
        current += self.create_node(UnlexerRule(src='true'))
        return current
    True_.min_depth = 0

    @depthcontrol
    def Try(self):
        current = self.create_node(UnlexerRule(name='Try'))
        current += self.create_node(UnlexerRule(src='try'))
        return current
    Try.min_depth = 0

    @depthcontrol
    def Typedef(self):
        current = self.create_node(UnlexerRule(name='Typedef'))
        current += self.create_node(UnlexerRule(src='typedef'))
        return current
    Typedef.min_depth = 0

    @depthcontrol
    def Typeid_(self):
        current = self.create_node(UnlexerRule(name='Typeid_'))
        current += self.create_node(UnlexerRule(src='typeid'))
        return current
    Typeid_.min_depth = 0

    @depthcontrol
    def Typename_(self):
        current = self.create_node(UnlexerRule(name='Typename_'))
        current += self.create_node(UnlexerRule(src='typename'))
        return current
    Typename_.min_depth = 0

    @depthcontrol
    def Union(self):
        current = self.create_node(UnlexerRule(name='Union'))
        current += self.create_node(UnlexerRule(src='union'))
        return current
    Union.min_depth = 0

    @depthcontrol
    def Unsigned(self):
        current = self.create_node(UnlexerRule(name='Unsigned'))
        current += self.create_node(UnlexerRule(src='unsigned'))
        return current
    Unsigned.min_depth = 0

    @depthcontrol
    def Using(self):
        current = self.create_node(UnlexerRule(name='Using'))
        current += self.create_node(UnlexerRule(src='using'))
        return current
    Using.min_depth = 0

    @depthcontrol
    def Virtual(self):
        current = self.create_node(UnlexerRule(name='Virtual'))
        current += self.create_node(UnlexerRule(src='virtual'))
        return current
    Virtual.min_depth = 0

    @depthcontrol
    def Void(self):
        current = self.create_node(UnlexerRule(name='Void'))
        current += self.create_node(UnlexerRule(src='void'))
        return current
    Void.min_depth = 0

    @depthcontrol
    def Volatile(self):
        current = self.create_node(UnlexerRule(name='Volatile'))
        current += self.create_node(UnlexerRule(src='volatile'))
        return current
    Volatile.min_depth = 0

    @depthcontrol
    def Wchar(self):
        current = self.create_node(UnlexerRule(name='Wchar'))
        current += self.create_node(UnlexerRule(src='wchar_t'))
        return current
    Wchar.min_depth = 0

    @depthcontrol
    def While(self):
        current = self.create_node(UnlexerRule(name='While'))
        current += self.create_node(UnlexerRule(src='while'))
        return current
    While.min_depth = 0

    @depthcontrol
    def LeftParen(self):
        current = self.create_node(UnlexerRule(name='LeftParen'))
        current += self.create_node(UnlexerRule(src='('))
        return current
    LeftParen.min_depth = 0

    @depthcontrol
    def RightParen(self):
        current = self.create_node(UnlexerRule(name='RightParen'))
        current += self.create_node(UnlexerRule(src=')'))
        return current
    RightParen.min_depth = 0

    @depthcontrol
    def LeftBracket(self):
        current = self.create_node(UnlexerRule(name='LeftBracket'))
        current += self.create_node(UnlexerRule(src='['))
        return current
    LeftBracket.min_depth = 0

    @depthcontrol
    def RightBracket(self):
        current = self.create_node(UnlexerRule(name='RightBracket'))
        current += self.create_node(UnlexerRule(src=']'))
        return current
    RightBracket.min_depth = 0

    @depthcontrol
    def LeftBrace(self):
        current = self.create_node(UnlexerRule(name='LeftBrace'))
        current += self.create_node(UnlexerRule(src='{'))
        return current
    LeftBrace.min_depth = 0

    @depthcontrol
    def RightBrace(self):
        current = self.create_node(UnlexerRule(name='RightBrace'))
        current += self.create_node(UnlexerRule(src='}'))
        return current
    RightBrace.min_depth = 0

    @depthcontrol
    def Plus(self):
        current = self.create_node(UnlexerRule(name='Plus'))
        current += self.create_node(UnlexerRule(src='+'))
        return current
    Plus.min_depth = 0

    @depthcontrol
    def Minus(self):
        current = self.create_node(UnlexerRule(name='Minus'))
        current += self.create_node(UnlexerRule(src='-'))
        return current
    Minus.min_depth = 0

    @depthcontrol
    def Star(self):
        current = self.create_node(UnlexerRule(name='Star'))
        current += self.create_node(UnlexerRule(src='*'))
        return current
    Star.min_depth = 0

    @depthcontrol
    def Div(self):
        current = self.create_node(UnlexerRule(name='Div'))
        current += self.create_node(UnlexerRule(src='/'))
        return current
    Div.min_depth = 0

    @depthcontrol
    def Mod(self):
        current = self.create_node(UnlexerRule(name='Mod'))
        current += self.create_node(UnlexerRule(src='%'))
        return current
    Mod.min_depth = 0

    @depthcontrol
    def Caret(self):
        current = self.create_node(UnlexerRule(name='Caret'))
        current += self.create_node(UnlexerRule(src='^'))
        return current
    Caret.min_depth = 0

    @depthcontrol
    def And(self):
        current = self.create_node(UnlexerRule(name='And'))
        current += self.create_node(UnlexerRule(src='&'))
        return current
    And.min_depth = 0

    @depthcontrol
    def Or(self):
        current = self.create_node(UnlexerRule(name='Or'))
        current += self.create_node(UnlexerRule(src='|'))
        return current
    Or.min_depth = 0

    @depthcontrol
    def Tilde(self):
        current = self.create_node(UnlexerRule(name='Tilde'))
        current += self.create_node(UnlexerRule(src='~'))
        return current
    Tilde.min_depth = 0

    @depthcontrol
    def Not(self):
        current = self.create_node(UnlexerRule(name='Not'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_98', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_98', choice)] = self.unlexer.weights.get(('alt_98', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='!'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='not'))
        return current
    Not.min_depth = 0

    @depthcontrol
    def Assign(self):
        current = self.create_node(UnlexerRule(name='Assign'))
        current += self.create_node(UnlexerRule(src='='))
        return current
    Assign.min_depth = 0

    @depthcontrol
    def Less(self):
        current = self.create_node(UnlexerRule(name='Less'))
        current += self.create_node(UnlexerRule(src='<'))
        return current
    Less.min_depth = 0

    @depthcontrol
    def Greater(self):
        current = self.create_node(UnlexerRule(name='Greater'))
        current += self.create_node(UnlexerRule(src='>'))
        return current
    Greater.min_depth = 0

    @depthcontrol
    def PlusAssign(self):
        current = self.create_node(UnlexerRule(name='PlusAssign'))
        current += self.create_node(UnlexerRule(src='+='))
        return current
    PlusAssign.min_depth = 0

    @depthcontrol
    def MinusAssign(self):
        current = self.create_node(UnlexerRule(name='MinusAssign'))
        current += self.create_node(UnlexerRule(src='-='))
        return current
    MinusAssign.min_depth = 0

    @depthcontrol
    def StarAssign(self):
        current = self.create_node(UnlexerRule(name='StarAssign'))
        current += self.create_node(UnlexerRule(src='*='))
        return current
    StarAssign.min_depth = 0

    @depthcontrol
    def DivAssign(self):
        current = self.create_node(UnlexerRule(name='DivAssign'))
        current += self.create_node(UnlexerRule(src='/='))
        return current
    DivAssign.min_depth = 0

    @depthcontrol
    def ModAssign(self):
        current = self.create_node(UnlexerRule(name='ModAssign'))
        current += self.create_node(UnlexerRule(src='%='))
        return current
    ModAssign.min_depth = 0

    @depthcontrol
    def XorAssign(self):
        current = self.create_node(UnlexerRule(name='XorAssign'))
        current += self.create_node(UnlexerRule(src='^='))
        return current
    XorAssign.min_depth = 0

    @depthcontrol
    def AndAssign(self):
        current = self.create_node(UnlexerRule(name='AndAssign'))
        current += self.create_node(UnlexerRule(src='&='))
        return current
    AndAssign.min_depth = 0

    @depthcontrol
    def OrAssign(self):
        current = self.create_node(UnlexerRule(name='OrAssign'))
        current += self.create_node(UnlexerRule(src='|='))
        return current
    OrAssign.min_depth = 0

    @depthcontrol
    def LeftShift(self):
        current = self.create_node(UnlexerRule(name='LeftShift'))
        current += self.create_node(UnlexerRule(src='<<'))
        return current
    LeftShift.min_depth = 0

    @depthcontrol
    def RightShift(self):
        current = self.create_node(UnlexerRule(name='RightShift'))
        current += self.create_node(UnlexerRule(src='>>'))
        return current
    RightShift.min_depth = 0

    @depthcontrol
    def LeftShiftAssign(self):
        current = self.create_node(UnlexerRule(name='LeftShiftAssign'))
        current += self.create_node(UnlexerRule(src='<<='))
        return current
    LeftShiftAssign.min_depth = 0

    @depthcontrol
    def RightShiftAssign(self):
        current = self.create_node(UnlexerRule(name='RightShiftAssign'))
        current += self.create_node(UnlexerRule(src='>>='))
        return current
    RightShiftAssign.min_depth = 0

    @depthcontrol
    def Equal(self):
        current = self.create_node(UnlexerRule(name='Equal'))
        current += self.create_node(UnlexerRule(src='=='))
        return current
    Equal.min_depth = 0

    @depthcontrol
    def NotEqual(self):
        current = self.create_node(UnlexerRule(name='NotEqual'))
        current += self.create_node(UnlexerRule(src='!='))
        return current
    NotEqual.min_depth = 0

    @depthcontrol
    def LessEqual(self):
        current = self.create_node(UnlexerRule(name='LessEqual'))
        current += self.create_node(UnlexerRule(src='<='))
        return current
    LessEqual.min_depth = 0

    @depthcontrol
    def GreaterEqual(self):
        current = self.create_node(UnlexerRule(name='GreaterEqual'))
        current += self.create_node(UnlexerRule(src='>='))
        return current
    GreaterEqual.min_depth = 0

    @depthcontrol
    def AndAnd(self):
        current = self.create_node(UnlexerRule(name='AndAnd'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_122', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_122', choice)] = self.unlexer.weights.get(('alt_122', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='&&'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='and'))
        return current
    AndAnd.min_depth = 0

    @depthcontrol
    def OrOr(self):
        current = self.create_node(UnlexerRule(name='OrOr'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_127', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_127', choice)] = self.unlexer.weights.get(('alt_127', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='||'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='or'))
        return current
    OrOr.min_depth = 0

    @depthcontrol
    def PlusPlus(self):
        current = self.create_node(UnlexerRule(name='PlusPlus'))
        current += self.create_node(UnlexerRule(src='++'))
        return current
    PlusPlus.min_depth = 0

    @depthcontrol
    def MinusMinus(self):
        current = self.create_node(UnlexerRule(name='MinusMinus'))
        current += self.create_node(UnlexerRule(src='--'))
        return current
    MinusMinus.min_depth = 0

    @depthcontrol
    def Comma(self):
        current = self.create_node(UnlexerRule(name='Comma'))
        current += self.create_node(UnlexerRule(src=','))
        return current
    Comma.min_depth = 0

    @depthcontrol
    def ArrowStar(self):
        current = self.create_node(UnlexerRule(name='ArrowStar'))
        current += self.create_node(UnlexerRule(src='->*'))
        return current
    ArrowStar.min_depth = 0

    @depthcontrol
    def Arrow(self):
        current = self.create_node(UnlexerRule(name='Arrow'))
        current += self.create_node(UnlexerRule(src='->'))
        return current
    Arrow.min_depth = 0

    @depthcontrol
    def Question(self):
        current = self.create_node(UnlexerRule(name='Question'))
        current += self.create_node(UnlexerRule(src='?'))
        return current
    Question.min_depth = 0

    @depthcontrol
    def Colon(self):
        current = self.create_node(UnlexerRule(name='Colon'))
        current += self.create_node(UnlexerRule(src=':'))
        return current
    Colon.min_depth = 0

    @depthcontrol
    def Doublecolon(self):
        current = self.create_node(UnlexerRule(name='Doublecolon'))
        current += self.create_node(UnlexerRule(src='::'))
        return current
    Doublecolon.min_depth = 0

    @depthcontrol
    def Semi(self):
        current = self.create_node(UnlexerRule(name='Semi'))
        current += self.create_node(UnlexerRule(src=';'))
        return current
    Semi.min_depth = 0

    @depthcontrol
    def Dot(self):
        current = self.create_node(UnlexerRule(name='Dot'))
        current += self.create_node(UnlexerRule(src='.'))
        return current
    Dot.min_depth = 0

    @depthcontrol
    def DotStar(self):
        current = self.create_node(UnlexerRule(name='DotStar'))
        current += self.create_node(UnlexerRule(src='.*'))
        return current
    DotStar.min_depth = 0

    @depthcontrol
    def Ellipsis(self):
        current = self.create_node(UnlexerRule(name='Ellipsis'))
        current += self.create_node(UnlexerRule(src='...'))
        return current
    Ellipsis.min_depth = 0

    @depthcontrol
    def Hexquad(self):
        current = self.create_node(UnlexerRule(name='Hexquad'))
        current += self.unlexer.HEXADECIMALDIGIT()
        current += self.unlexer.HEXADECIMALDIGIT()
        current += self.unlexer.HEXADECIMALDIGIT()
        current += self.unlexer.HEXADECIMALDIGIT()
        return current
    Hexquad.min_depth = 1

    @depthcontrol
    def Universalcharactername(self):
        current = self.create_node(UnlexerRule(name='Universalcharactername'))
        choice = self.choice([0 if [2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_144', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_144', choice)] = self.unlexer.weights.get(('alt_144', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='\\u'))
            current += self.unlexer.Hexquad()
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='\\U'))
            current += self.unlexer.Hexquad()
            current += self.unlexer.Hexquad()
        return current
    Universalcharactername.min_depth = 2

    @depthcontrol
    def Identifier(self):
        current = self.create_node(UnlexerRule(name='Identifier'))
        current += self.unlexer.Identifiernondigit()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                choice = self.choice([0 if [2, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_150', i), 1) for i, w in enumerate([1, 1])])
                self.unlexer.weights[('alt_150', choice)] = self.unlexer.weights.get(('alt_150', choice), 1) * self.unlexer.cooldown
                if choice == 0:
                    current += self.unlexer.Identifiernondigit()
                elif choice == 1:
                    current += self.unlexer.DIGIT()

        return current
    Identifier.min_depth = 2

    @depthcontrol
    def Identifiernondigit(self):
        current = self.create_node(UnlexerRule(name='Identifiernondigit'))
        choice = self.choice([0 if [1, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_153', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_153', choice)] = self.unlexer.weights.get(('alt_153', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.NONDIGIT()
        elif choice == 1:
            current += self.unlexer.Universalcharactername()
        return current
    Identifiernondigit.min_depth = 1

    @depthcontrol
    def NONDIGIT(self):
        current = self.create_node(UnlexerRule(name='NONDIGIT'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_3)))
        return current
    NONDIGIT.min_depth = 0

    @depthcontrol
    def DIGIT(self):
        current = self.create_node(UnlexerRule(name='DIGIT'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_4)))
        return current
    DIGIT.min_depth = 0

    @depthcontrol
    def Integerliteral(self):
        current = self.create_node(UnlexerRule(name='Integerliteral'))
        choice = self.choice([0 if [2, 1, 2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_156', i), 1) for i, w in enumerate([1, 1, 1, 1])])
        self.unlexer.weights[('alt_156', choice)] = self.unlexer.weights.get(('alt_156', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.Decimalliteral()
            if self.unlexer.max_depth >= 2:
                for _ in self.zero_or_one():
                    current += self.unlexer.Integersuffix()

        elif choice == 1:
            current += self.unlexer.Octalliteral()
            if self.unlexer.max_depth >= 2:
                for _ in self.zero_or_one():
                    current += self.unlexer.Integersuffix()

        elif choice == 2:
            current += self.unlexer.Hexadecimalliteral()
            if self.unlexer.max_depth >= 2:
                for _ in self.zero_or_one():
                    current += self.unlexer.Integersuffix()

        elif choice == 3:
            current += self.unlexer.Binaryliteral()
            if self.unlexer.max_depth >= 2:
                for _ in self.zero_or_one():
                    current += self.unlexer.Integersuffix()

        return current
    Integerliteral.min_depth = 1

    @depthcontrol
    def Decimalliteral(self):
        current = self.create_node(UnlexerRule(name='Decimalliteral'))
        current += self.unlexer.NONZERODIGIT()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                if self.unlexer.max_depth >= 0:
                    for _ in self.zero_or_one():
                        current += self.create_node(UnlexerRule(src='\''))

                current += self.unlexer.DIGIT()

        return current
    Decimalliteral.min_depth = 1

    @depthcontrol
    def Octalliteral(self):
        current = self.create_node(UnlexerRule(name='Octalliteral'))
        current += self.create_node(UnlexerRule(src='0'))
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                if self.unlexer.max_depth >= 0:
                    for _ in self.zero_or_one():
                        current += self.create_node(UnlexerRule(src='\''))

                current += self.unlexer.OCTALDIGIT()

        return current
    Octalliteral.min_depth = 0

    @depthcontrol
    def Hexadecimalliteral(self):
        current = self.create_node(UnlexerRule(name='Hexadecimalliteral'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_172', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_172', choice)] = self.unlexer.weights.get(('alt_172', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='0x'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='0X'))
        current += self.unlexer.HEXADECIMALDIGIT()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                if self.unlexer.max_depth >= 0:
                    for _ in self.zero_or_one():
                        current += self.create_node(UnlexerRule(src='\''))

                current += self.unlexer.HEXADECIMALDIGIT()

        return current
    Hexadecimalliteral.min_depth = 1

    @depthcontrol
    def Binaryliteral(self):
        current = self.create_node(UnlexerRule(name='Binaryliteral'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_180', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_180', choice)] = self.unlexer.weights.get(('alt_180', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='0b'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='0B'))
        current += self.unlexer.BINARYDIGIT()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                if self.unlexer.max_depth >= 0:
                    for _ in self.zero_or_one():
                        current += self.create_node(UnlexerRule(src='\''))

                current += self.unlexer.BINARYDIGIT()

        return current
    Binaryliteral.min_depth = 1

    @depthcontrol
    def NONZERODIGIT(self):
        current = self.create_node(UnlexerRule(name='NONZERODIGIT'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_5)))
        return current
    NONZERODIGIT.min_depth = 0

    @depthcontrol
    def OCTALDIGIT(self):
        current = self.create_node(UnlexerRule(name='OCTALDIGIT'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_6)))
        return current
    OCTALDIGIT.min_depth = 0

    @depthcontrol
    def HEXADECIMALDIGIT(self):
        current = self.create_node(UnlexerRule(name='HEXADECIMALDIGIT'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_7)))
        return current
    HEXADECIMALDIGIT.min_depth = 0

    @depthcontrol
    def BINARYDIGIT(self):
        current = self.create_node(UnlexerRule(name='BINARYDIGIT'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_8)))
        return current
    BINARYDIGIT.min_depth = 0

    @depthcontrol
    def Integersuffix(self):
        current = self.create_node(UnlexerRule(name='Integersuffix'))
        choice = self.choice([0 if [1, 1, 1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_188', i), 1) for i, w in enumerate([1, 1, 1, 1])])
        self.unlexer.weights[('alt_188', choice)] = self.unlexer.weights.get(('alt_188', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.Unsignedsuffix()
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_one():
                    current += self.unlexer.Longsuffix()

        elif choice == 1:
            current += self.unlexer.Unsignedsuffix()
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_one():
                    current += self.unlexer.Longlongsuffix()

        elif choice == 2:
            current += self.unlexer.Longsuffix()
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_one():
                    current += self.unlexer.Unsignedsuffix()

        elif choice == 3:
            current += self.unlexer.Longlongsuffix()
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_one():
                    current += self.unlexer.Unsignedsuffix()

        return current
    Integersuffix.min_depth = 1

    @depthcontrol
    def Unsignedsuffix(self):
        current = self.create_node(UnlexerRule(name='Unsignedsuffix'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_9)))
        return current
    Unsignedsuffix.min_depth = 0

    @depthcontrol
    def Longsuffix(self):
        current = self.create_node(UnlexerRule(name='Longsuffix'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_10)))
        return current
    Longsuffix.min_depth = 0

    @depthcontrol
    def Longlongsuffix(self):
        current = self.create_node(UnlexerRule(name='Longlongsuffix'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_197', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_197', choice)] = self.unlexer.weights.get(('alt_197', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='ll'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='LL'))
        return current
    Longlongsuffix.min_depth = 0

    @depthcontrol
    def Characterliteral(self):
        current = self.create_node(UnlexerRule(name='Characterliteral'))
        choice = self.choice([0 if [1, 1, 1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_202', i), 1) for i, w in enumerate([1, 1, 1, 1])])
        self.unlexer.weights[('alt_202', choice)] = self.unlexer.weights.get(('alt_202', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='\''))
            if self.unlexer.max_depth >= 0:
                for _ in self.one_or_more():
                    current += self.unlexer.Cchar()

            current += self.create_node(UnlexerRule(src='\''))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='u'))
            current += self.create_node(UnlexerRule(src='\''))
            if self.unlexer.max_depth >= 0:
                for _ in self.one_or_more():
                    current += self.unlexer.Cchar()

            current += self.create_node(UnlexerRule(src='\''))
        elif choice == 2:
            current += self.create_node(UnlexerRule(src='U'))
            current += self.create_node(UnlexerRule(src='\''))
            if self.unlexer.max_depth >= 0:
                for _ in self.one_or_more():
                    current += self.unlexer.Cchar()

            current += self.create_node(UnlexerRule(src='\''))
        elif choice == 3:
            current += self.create_node(UnlexerRule(src='L'))
            current += self.create_node(UnlexerRule(src='\''))
            if self.unlexer.max_depth >= 0:
                for _ in self.one_or_more():
                    current += self.unlexer.Cchar()

            current += self.create_node(UnlexerRule(src='\''))
        return current
    Characterliteral.min_depth = 1

    @depthcontrol
    def Cchar(self):
        current = self.create_node(UnlexerRule(name='Cchar'))
        choice = self.choice([0 if [0, 2, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_218', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_218', choice)] = self.unlexer.weights.get(('alt_218', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += UnlexerRule(src=self.char_from_list(charset_11))
        elif choice == 1:
            current += self.unlexer.Escapesequence()
        elif choice == 2:
            current += self.unlexer.Universalcharactername()
        return current
    Cchar.min_depth = 0

    @depthcontrol
    def Escapesequence(self):
        current = self.create_node(UnlexerRule(name='Escapesequence'))
        choice = self.choice([0 if [1, 2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_222', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_222', choice)] = self.unlexer.weights.get(('alt_222', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.Simpleescapesequence()
        elif choice == 1:
            current += self.unlexer.Octalescapesequence()
        elif choice == 2:
            current += self.unlexer.Hexadecimalescapesequence()
        return current
    Escapesequence.min_depth = 1

    @depthcontrol
    def Simpleescapesequence(self):
        current = self.create_node(UnlexerRule(name='Simpleescapesequence'))
        choice = self.choice([0 if [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_226', i), 1) for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        self.unlexer.weights[('alt_226', choice)] = self.unlexer.weights.get(('alt_226', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='\\\''))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='\\"'))
        elif choice == 2:
            current += self.create_node(UnlexerRule(src='\\?'))
        elif choice == 3:
            current += self.create_node(UnlexerRule(src='\\\\'))
        elif choice == 4:
            current += self.create_node(UnlexerRule(src='\\a'))
        elif choice == 5:
            current += self.create_node(UnlexerRule(src='\\b'))
        elif choice == 6:
            current += self.create_node(UnlexerRule(src='\\f'))
        elif choice == 7:
            current += self.create_node(UnlexerRule(src='\\n'))
        elif choice == 8:
            current += self.create_node(UnlexerRule(src='\\r'))
        elif choice == 9:
            current += self.create_node(UnlexerRule(src='\\t'))
        elif choice == 10:
            current += self.create_node(UnlexerRule(src='\\v'))
        return current
    Simpleescapesequence.min_depth = 0

    @depthcontrol
    def Octalescapesequence(self):
        current = self.create_node(UnlexerRule(name='Octalescapesequence'))
        choice = self.choice([0 if [1, 1, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_249', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_249', choice)] = self.unlexer.weights.get(('alt_249', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='\\'))
            current += self.unlexer.OCTALDIGIT()
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='\\'))
            current += self.unlexer.OCTALDIGIT()
            current += self.unlexer.OCTALDIGIT()
        elif choice == 2:
            current += self.create_node(UnlexerRule(src='\\'))
            current += self.unlexer.OCTALDIGIT()
            current += self.unlexer.OCTALDIGIT()
            current += self.unlexer.OCTALDIGIT()
        return current
    Octalescapesequence.min_depth = 1

    @depthcontrol
    def Hexadecimalescapesequence(self):
        current = self.create_node(UnlexerRule(name='Hexadecimalescapesequence'))
        current += self.create_node(UnlexerRule(src='\\x'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.unlexer.HEXADECIMALDIGIT()

        return current
    Hexadecimalescapesequence.min_depth = 1

    @depthcontrol
    def Floatingliteral(self):
        current = self.create_node(UnlexerRule(name='Floatingliteral'))
        choice = self.choice([0 if [3, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_257', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_257', choice)] = self.unlexer.weights.get(('alt_257', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.Fractionalconstant()
            if self.unlexer.max_depth >= 3:
                for _ in self.zero_or_one():
                    current += self.unlexer.Exponentpart()

            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_one():
                    current += self.unlexer.Floatingsuffix()

        elif choice == 1:
            current += self.unlexer.Digitsequence()
            current += self.unlexer.Exponentpart()
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_one():
                    current += self.unlexer.Floatingsuffix()

        return current
    Floatingliteral.min_depth = 3

    @depthcontrol
    def Fractionalconstant(self):
        current = self.create_node(UnlexerRule(name='Fractionalconstant'))
        choice = self.choice([0 if [2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_263', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_263', choice)] = self.unlexer.weights.get(('alt_263', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            if self.unlexer.max_depth >= 2:
                for _ in self.zero_or_one():
                    current += self.unlexer.Digitsequence()

            current += self.create_node(UnlexerRule(src='.'))
            current += self.unlexer.Digitsequence()
        elif choice == 1:
            current += self.unlexer.Digitsequence()
            current += self.create_node(UnlexerRule(src='.'))
        return current
    Fractionalconstant.min_depth = 2

    @depthcontrol
    def Exponentpart(self):
        current = self.create_node(UnlexerRule(name='Exponentpart'))
        choice = self.choice([0 if [2, 2][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_269', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_269', choice)] = self.unlexer.weights.get(('alt_269', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='e'))
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_one():
                    current += self.unlexer.SIGN()

            current += self.unlexer.Digitsequence()
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='E'))
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_one():
                    current += self.unlexer.SIGN()

            current += self.unlexer.Digitsequence()
        return current
    Exponentpart.min_depth = 2

    @depthcontrol
    def SIGN(self):
        current = self.create_node(UnlexerRule(name='SIGN'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_12)))
        return current
    SIGN.min_depth = 0

    @depthcontrol
    def Digitsequence(self):
        current = self.create_node(UnlexerRule(name='Digitsequence'))
        current += self.unlexer.DIGIT()
        if self.unlexer.max_depth >= 1:
            for _ in self.zero_or_more():
                if self.unlexer.max_depth >= 0:
                    for _ in self.zero_or_one():
                        current += self.create_node(UnlexerRule(src='\''))

                current += self.unlexer.DIGIT()

        return current
    Digitsequence.min_depth = 1

    @depthcontrol
    def Floatingsuffix(self):
        current = self.create_node(UnlexerRule(name='Floatingsuffix'))
        current += self.create_node(UnlexerRule(src=self.char_from_list(charset_13)))
        return current
    Floatingsuffix.min_depth = 0

    @depthcontrol
    def Stringliteral(self):
        current = self.create_node(UnlexerRule(name='Stringliteral'))
        choice = self.choice([0 if [0, 1][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_279', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_279', choice)] = self.unlexer.weights.get(('alt_279', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_one():
                    current += self.unlexer.Encodingprefix()

            current += self.create_node(UnlexerRule(src='"'))
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_more():
                    current += self.unlexer.Schar()

            current += self.create_node(UnlexerRule(src='"'))
        elif choice == 1:
            if self.unlexer.max_depth >= 1:
                for _ in self.zero_or_one():
                    current += self.unlexer.Encodingprefix()

            current += self.create_node(UnlexerRule(src='R'))
            current += self.unlexer.Rawstring()
        return current
    Stringliteral.min_depth = 0

    @depthcontrol
    def Encodingprefix(self):
        current = self.create_node(UnlexerRule(name='Encodingprefix'))
        choice = self.choice([0 if [0, 0, 0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_288', i), 1) for i, w in enumerate([1, 1, 1, 1])])
        self.unlexer.weights[('alt_288', choice)] = self.unlexer.weights.get(('alt_288', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='u8'))
        elif choice == 1:
            current += self.create_node(UnlexerRule(src='u'))
        elif choice == 2:
            current += self.create_node(UnlexerRule(src='U'))
        elif choice == 3:
            current += self.create_node(UnlexerRule(src='L'))
        return current
    Encodingprefix.min_depth = 0

    @depthcontrol
    def Schar(self):
        current = self.create_node(UnlexerRule(name='Schar'))
        choice = self.choice([0 if [0, 2, 3][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_297', i), 1) for i, w in enumerate([1, 1, 1])])
        self.unlexer.weights[('alt_297', choice)] = self.unlexer.weights.get(('alt_297', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += UnlexerRule(src=self.char_from_list(charset_14))
        elif choice == 1:
            current += self.unlexer.Escapesequence()
        elif choice == 2:
            current += self.unlexer.Universalcharactername()
        return current
    Schar.min_depth = 0

    @depthcontrol
    def Rawstring(self):
        current = self.create_node(UnlexerRule(name='Rawstring'))
        current += self.create_node(UnlexerRule(src='"'))
        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_more():
                current += UnlexerRule(src=self.any_char())

        current += self.create_node(UnlexerRule(src='('))
        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_more():
                current += UnlexerRule(src=self.any_char())

        current += self.create_node(UnlexerRule(src=')'))
        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_more():
                current += UnlexerRule(src=self.any_char())

        current += self.create_node(UnlexerRule(src='"'))
        return current
    Rawstring.min_depth = 0

    @depthcontrol
    def Userdefinedintegerliteral(self):
        current = self.create_node(UnlexerRule(name='Userdefinedintegerliteral'))
        choice = self.choice([0 if [4, 4, 4, 4][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_308', i), 1) for i, w in enumerate([1, 1, 1, 1])])
        self.unlexer.weights[('alt_308', choice)] = self.unlexer.weights.get(('alt_308', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.Decimalliteral()
            current += self.unlexer.Udsuffix()
        elif choice == 1:
            current += self.unlexer.Octalliteral()
            current += self.unlexer.Udsuffix()
        elif choice == 2:
            current += self.unlexer.Hexadecimalliteral()
            current += self.unlexer.Udsuffix()
        elif choice == 3:
            current += self.unlexer.Binaryliteral()
            current += self.unlexer.Udsuffix()
        return current
    Userdefinedintegerliteral.min_depth = 4

    @depthcontrol
    def Userdefinedfloatingliteral(self):
        current = self.create_node(UnlexerRule(name='Userdefinedfloatingliteral'))
        choice = self.choice([0 if [4, 4][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_313', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_313', choice)] = self.unlexer.weights.get(('alt_313', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.unlexer.Fractionalconstant()
            if self.unlexer.max_depth >= 3:
                for _ in self.zero_or_one():
                    current += self.unlexer.Exponentpart()

            current += self.unlexer.Udsuffix()
        elif choice == 1:
            current += self.unlexer.Digitsequence()
            current += self.unlexer.Exponentpart()
            current += self.unlexer.Udsuffix()
        return current
    Userdefinedfloatingliteral.min_depth = 4

    @depthcontrol
    def Userdefinedstringliteral(self):
        current = self.create_node(UnlexerRule(name='Userdefinedstringliteral'))
        current += self.unlexer.Stringliteral()
        current += self.unlexer.Udsuffix()
        return current
    Userdefinedstringliteral.min_depth = 4

    @depthcontrol
    def Userdefinedcharacterliteral(self):
        current = self.create_node(UnlexerRule(name='Userdefinedcharacterliteral'))
        current += self.unlexer.Characterliteral()
        current += self.unlexer.Udsuffix()
        return current
    Userdefinedcharacterliteral.min_depth = 4

    @depthcontrol
    def Udsuffix(self):
        current = self.create_node(UnlexerRule(name='Udsuffix'))
        current += self.unlexer.Identifier()
        return current
    Udsuffix.min_depth = 3

    @depthcontrol
    def Whitespace(self):
        current = self.create_node(UnlexerRule(name='Whitespace'))
        if self.unlexer.max_depth >= 0:
            for _ in self.one_or_more():
                current += self.create_node(UnlexerRule(src=self.char_from_list(charset_15)))

        return current
    Whitespace.min_depth = 0

    @depthcontrol
    def Newline(self):
        current = self.create_node(UnlexerRule(name='Newline'))
        choice = self.choice([0 if [0, 0][i] > self.unlexer.max_depth else w * self.unlexer.weights.get(('alt_317', i), 1) for i, w in enumerate([1, 1])])
        self.unlexer.weights[('alt_317', choice)] = self.unlexer.weights.get(('alt_317', choice), 1) * self.unlexer.cooldown
        if choice == 0:
            current += self.create_node(UnlexerRule(src='\r'))
            if self.unlexer.max_depth >= 0:
                for _ in self.zero_or_one():
                    current += self.create_node(UnlexerRule(src='\n'))

        elif choice == 1:
            current += self.create_node(UnlexerRule(src='\n'))
        return current
    Newline.min_depth = 0

    @depthcontrol
    def BlockComment(self):
        current = self.create_node(UnlexerRule(name='BlockComment'))
        current += self.create_node(UnlexerRule(src='/*'))
        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_more():
                current += UnlexerRule(src=self.any_char())

        current += self.create_node(UnlexerRule(src='*/'))
        return current
    BlockComment.min_depth = 0

    @depthcontrol
    def LineComment(self):
        current = self.create_node(UnlexerRule(name='LineComment'))
        current += self.create_node(UnlexerRule(src='//'))
        if self.unlexer.max_depth >= 0:
            for _ in self.zero_or_more():
                current += UnlexerRule(src=self.char_from_list(charset_16))

        return current
    LineComment.min_depth = 0

